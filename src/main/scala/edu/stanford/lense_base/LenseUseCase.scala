package edu.stanford.lense_base

import edu.stanford.lense_base.gameplaying.{LookaheadOneHeuristic, GamePlayer}
import edu.stanford.lense_base.graph.{GraphNode, GraphStream, Graph}
import edu.stanford.lense_base.server.{MulticlassQuestion, WorkUnitServlet, WorkUnit}

import scala.concurrent.Promise

case class GraphNodeAnswer(displayText : String, internalClassName : String)
case class GraphNodeQuestion(questionToDisplay : String, possibleAnswers : List[GraphNodeAnswer]) {
  def getHumanOpinion : Promise[String] = {
    val p = Promise[String]()
    WorkUnitServlet.addWorkUnit(
      new MulticlassQuestion(
        questionToDisplay,
        possibleAnswers.map(_.displayText),
        p
      )
    )
    p
  }
}

/**
 * Created by keenon on 5/2/15.
 *
 * This holds the abstract guts of a use case for Lense, which should help minimize crufty overhead when generating new
 * use cases. You can of course still use LenseEngine directly, but this might be a time-saver in general
 */
abstract class LenseUseCase[Input <: AnyRef, Output <: AnyRef] {

  val graphStream : GraphStream = new GraphStream()
  val lenseEngine : LenseEngine = new LenseEngine(graphStream, gamePlayer)
  // Add the training data as a list of labeled graphs
  lenseEngine.addTrainingData(initialTrainingData.map(pair => toGraph(pair._1, pair._2)))

  /**
   * This function takes an Input, and an Output (which should be used to assign observedValue's if not null).
   * This must return a graph created in the local GraphStream.
   *
   * @param input the input that the graph will represent
   * @param output a possibly null correct output, that should be used to assign observedValue's to the graph
   * @return a graph representing the input, and taking labels from the output if it is passed in
   */
  def toGraph(input : Input, output : Output = Nil.asInstanceOf[Output]) : Graph

  /**
   * This function takes an Input, and the graph generated by toGraph(input), and generates a question to ask humans
   * for each node in the graph.

   * @param input the input that the graph represents
   * @param graph the graph generated by calling toGraph on the input
   * @return a map
   */
  def getHumanQuestions(input : Input, graph : Graph) : Map[GraphNode, GraphNodeQuestion]

  /**
   * Reads the MAP assignment out of the values object, and returns an Output corresponding to this graph having these
   * values.
   * The keys of the values map will always correspond one-to-one with the nodes of the graph.
   *
   * @param graph the graph, with observedValue's on all the nodes
   * @param values a map corresponding the nodes of the graph with their String labels
   * @return an Output version of this graph
   */
  def toOutput(graph : Graph, values : Map[GraphNode, String]) : Output

  /**
   * An opportunity to provide some seed data for training the model before the online task begins. This data will
   * be used to train the classifier prior to any testing or online activity
   *
   * @return model seed training data
   */
  def initialTrainingData : List[(Input, Output)] = List()

  /**
   * An opportunity to provide a new game player, besides the default
   *
   * @return a game player
   */
  def gamePlayer : GamePlayer = LookaheadOneHeuristic

  ////////////////////////////////////////////////
  //
  //  These are functions that LenseUseCase provides, assuming the above are correct
  //
  ////////////////////////////////////////////////

  /**
   * This will run a test against artificial humans, with a "probability epsilon choose uniformly at random" error
   * function. It will print results to stdout.
   *
   * @param goldPairs pairs of Input and the corresponding correct Output objects
   * @param humanErrorRate the error rate epsilon, so if 0.3, then with P=0.3 artificial humans will choose uniformly at random
   */
  def testWithArtificialHumans(goldPairs : List[(Input, Output)], humanErrorRate : Double) : Unit = {
    //TODO
  }

  /**
   * This will run a test against real live humans. The LenseUseCase needs to be triggered from inside Jetty, once it's
   * running, so that there's a server to ask for human opinions.
   *
   * @param goldPairs pairs of Input and the corresponding correct Output objects
   */
  def testWithRealHumans(goldPairs : List[(Input, Output)]) : Unit = {
    //TODO
  }

  /**
   * Uses real humans and the existing LenseEngine to actually classify this example.
   *
   * @param input the input example
   * @return a classification of the Input
   */
  def classifyWithRealHumans(input : Input) : Output = {
    val graph = toGraph(input)
    val humanQuestionMap = getHumanQuestions(input, graph)
  }
}
